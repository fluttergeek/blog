I"´<p>Thanks to Roy Kronenfeldâ€™s <a href="https://medium.com/@roykronenfeld/semaphores-in-swift-e296ea80f860">Medium post</a> for this explanation of how to use a semaphore, specifically, utilizing the counter: <code class="highlighter-rouge">let semaphore = DispatchSemaphore(value: 0)</code>. Another <a href="https://www.youtube.com/watch?v=6rJN_ECd1XM">tutorial</a> was made by <code class="highlighter-rouge">Let's Build That App</code> but semaphore wasnâ€™t covered in great detail, and I think itâ€™s best if all iOS developers dive into the semaphore counters the way Roy did.</p>

<p>In Royâ€™s tutorial, itâ€™s more on semaphore counters. But if you want to see semaphore in action, kindly refer to my <a href="/blog/where-to-learn-async-callback-and-futures/">previous post</a> where it is applied on a <code class="highlighter-rouge">Futures</code> function.</p>

<p>His sample analogy was most brilliant. If you donâ€™t need to access a shared resource, feel free to use DispatchQueue. If you do, then you should consider <code class="highlighter-rouge">Semaphores</code>. The shared resource here is the <code class="highlighter-rouge">iPad</code> that 3 kids share. To cut the story short, there is only one iPad and our counter needs a value of only <code class="highlighter-rouge">1</code>.  Only one iPad can be shared among 3 kids at a time.</p>

<p>Another example of his is downloading songs. He wants 15 songs to be downloaded and he wants  to download 3 songs at a time. Therefore, youâ€™ve guessed it, the counter is set to <code class="highlighter-rouge">3</code>. The shared resource here is the downloading processes or threads, not the song.</p>

<p>You can use the semaphore in 2 different ways by <a href="https://stackoverflow.com/questions/37154877/creating-semaphore-with-initial-value-of-0-make-issues-with-execution">Wain from Stackoverflow</a> :</p>

<ol>
  <li>To limit the number of concurrent operations / requests / usages. In this case you start the semaphore at a positive value, like 4. The users each call wait and if resource is available they are allowed to continue. If not they are blocked. When each has finished with the resource they call signal. Just like the two examples given above.</li>
  <li>To say when work or a resource is ready and we want to proceed to main thread next. In this case you start the semaphore at 0. The creator calls signal when something is ready. Semaphores can be used when thereâ€™s an asynchronous API that you need to make synchronous, but you canâ€™t modify it. The example and explanation below is from <a href="http://khanlou.com/2016/04/the-GCD-handbook/">Soroush Khanlou</a>:</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// on a background queue
let semaphore = DispatchSemaphore(value: 0)
doSomeExpensiveWorkAsynchronously(completionBlock: {
	semaphore.signal()
})
semaphore.wait()
//the expensive asynchronous work is now done after calling semaphore.wait()
</code></pre></div></div>

<p>Calling .wait() will block the main thread until .signal() is called. This means that .signal() must be called from a different thread, since the current thread is totally blocked. Further, you should never call .wait() from the main thread, only from background threads.</p>

<p>If you want a more elaborate explanation on how this counting algorithm works, head on to his <a href="https://medium.com/@roykronenfeld/semaphores-in-swift-e296ea80f860">blog post</a> for more.</p>

:ET