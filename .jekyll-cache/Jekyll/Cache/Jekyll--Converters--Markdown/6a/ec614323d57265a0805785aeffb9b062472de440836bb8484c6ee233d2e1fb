I"è<p>Thanks to <a href="https://www.hackingwithswift.com/example-code/networking/how-to-check-for-internet-connectivity-using-nwpathmonitor">Paul Hudson @twostraws</a> for the informative knowledge on how to check for internet connection. Let me remind you that this solution is available since iOS 12.0. WWDC in June 2018 introduced the Network framework available from iOS 12 onwards which includes the NWPathMonitor class, which we will be using in this tutorial. Hereâ€™s a straight forward example of the basic implementation on how to check for internet connection.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import Network
private let monitor = NWPathMonitor()
monitor.start(queue: queue)
monitor.pathUpdateHandler = { path in
    if path.status == .satisfied {
        print("Online")
    } else {
        print("Offline)
    }
</code></pre></div></div>
<p>Itâ€™s so much shorter than the previous baffling solutions that you can find on stackoverflow. <a href="https://stackoverflow.com/questions/30743408/check-for-internet-connection-with-swift">Previous solutions</a> had to be particular about the connectivity. If itâ€™s coming from a WiFi, 4G, 3G or cellular data. My previous way of checking the internet connection was to use <code class="highlighter-rouge">Alamofire</code>â€™s network reachability feature which was way simpler than the other solutions, but I added a library that only uses this one feature. Hence, longer build time for something thatI didnâ€™t necessarily need. Now you donâ€™t even have to worry for the most part. Itâ€™s just that simple code that allows you to check for internet connectivity.</p>

<p>Now, I created something to allow me to check for the internet connection in different parts of my project without having to <code class="highlighter-rouge">import Network</code> all the damn time.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func online(completion: @escaping (Bool) -&gt; Void) {
    let monitor = NWPathMonitor()
    let queue = DispatchQueue.global(qos: .background)
    monitor.start(queue: queue)
    monitor.pathUpdateHandler = { path in
      var err = true
      defer {
        completion(err)
        monitor.cancel()
      }
      if path.status == .satisfied {
        err = false
      } else {
        self.showError(message: "Offline! :(")
        err = true
      }
    }
}
</code></pre></div></div>

<p>Note that the we have to cancel the network monitoring thatâ€™s been in the background thread, if you want to stop checking for the internet connection. If you donâ€™t cancel it, every time the connectivity changes, your monitor.pathUpdateHandler will execute itself again. I created this inside a singleton which allows me to call this method simply, anywhere, like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Singleton.sharedInstance.online { (err) in
    guard err == false else { return }
		
    // Do whatever online
}
</code></pre></div></div>

<p>Thereâ€™s a more elaborate article discussing how the <code class="highlighter-rouge">Network</code> framework can be used. Check <a href="https://medium.com/@rwbutler/nwpathmonitor-the-new-reachability-de101a5a8835">it</a> out.</p>

:ET