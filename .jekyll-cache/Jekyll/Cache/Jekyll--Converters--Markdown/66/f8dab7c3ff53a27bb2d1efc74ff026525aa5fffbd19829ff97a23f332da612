I"›<p>This is the most elegant solution I found on how to retrieve location with CoreLocation.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import CoreLocation
class ViewController: UIViewController {
    
    private let locationManager = CLLocationManager()
    private let operationQueue = OperationQueue()

    override func viewDidLoad() {
		super.viewDidLoad()
	
		operationQueue.isSuspended = true
		runLocationBlock {
			if let location = self.locationManager.location {
			}
		}
}
</code></pre></div></div>
<ol>
  <li>We must create a Location Manager first and foremost.</li>
  <li>We created an OperationQueue even though we only have one operation to execute, which is <code class="highlighter-rouge">runLocationBlock</code>.</li>
  <li>Suspend the operation or pause first to check if we are allowed to request location data.</li>
  <li>Whatever is in the <code class="highlighter-rouge">runLocationBlock</code> will only run if <code class="highlighter-rouge">operationQueue</code> is unsuspended but rest assured this function is already running.</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension ViewController: CLLocationManagerDelegate {
    private func configureLocationManager() {
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.delegate = self
				
        // requestLocation will take 10 seconds to run, but only requests location just once
        locationManager.requestLocation()
				
        // startUpdatingLocation will fire up immediately
        // locationManager.startUpdatingLocation()
    }
		
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("error")
    }
    
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        
        //If we're authorized to use location services, run all operations in the queue
        // otherwise if we were denied access or restricted or location is not determined, cancel the operations
				
        if(status == .authorizedWhenInUse || status == .authorizedAlways) {
            self.operationQueue.isSuspended = false
        }else if(status == .denied || status == .restricted || status == .notDetermined){
            self.operationQueue.cancelAllOperations()
        }
    }
    
    func runLocationBlock(callback: @escaping () -&gt; ()) {
        
        //Get the current authorization status
        let authState = CLLocationManager.authorizationStatus()
        
        //If we have permissions, start executing the commands immediately
        // otherwise request permission
        DispatchQueue.main.async {
            if(authState == .authorizedAlways || authState == .authorizedWhenInUse) {
                self.configureLocationManager()
                self.operationQueue.isSuspended = false
            }else{
                //Request permission
                self.locationManager.requestWhenInUseAuthorization()
            }
        }
        
        //Create a closure with the callback function so we can add it to the operationQueue
        let block = {
            DispatchQueue.main.async {
                callback()
            }
        }
        
        //Add block to the queue to be executed asynchronously
        self.operationQueue.addOperation(block)
    }
}
</code></pre></div></div>
<h2 id="runlocationblock"><code class="highlighter-rouge">RunLocationBlock</code></h2>
<ol>
  <li>We know for one thing that <code class="highlighter-rouge">runLocationBlock</code>â€™s operations is/are set suspended in the <code class="highlighter-rouge">ViewController</code>.</li>
  <li>We want to know the authorization status first.</li>
  <li>If we are authorized, then letâ€™s configure the <code class="highlighter-rouge">locationManager</code> second then unsuspend, next, to allow our operationQueue to run all the blocks of operations it cointains.</li>
  <li>If we are not authorized, a request will be shown to the user using the app.</li>
  <li>The <code class="highlighter-rouge">block</code> will contain the callback, which is whatever you put inside the <code class="highlighter-rouge">runLocationBlock { }</code>.</li>
</ol>

<h2 id="didchangeauthorization"><code class="highlighter-rouge">DidChangeAuthorization</code></h2>
<ol>
  <li>This is just like what weâ€™ve seen inside <code class="highlighter-rouge">runLocationBlock</code>, but we donâ€™t request for authorization again. Instead, when denied/restricted or if the location was not determined, then the <code class="highlighter-rouge">operationQueue</code> will not run operations that were added to it.</li>
  <li>This is only triggered after <code class="highlighter-rouge">self.locationManager.requestWhenInUseAuthorization()</code> that you have seen inside the <code class="highlighter-rouge">RunLocationBlock</code>.</li>
</ol>

<h2 id="configurelocationmanager"><code class="highlighter-rouge">ConfigureLocationManager</code></h2>
<ol>
  <li><code class="highlighter-rouge">locationManager.delegate = self</code> this is the most essential part of setting up our locationManager. This allows our <code class="highlighter-rouge">ViewController</code> to access protocol methods from <code class="highlighter-rouge">CLLocationManagerDelegate</code> like <code class="highlighter-rouge">didChangeAuthorization</code>.</li>
  <li>If the desiredAccuracy is not set, its default is <code class="highlighter-rouge">kCLLocationAccuracyBest</code> for iOS/Mac OS. For watchOS, <code class="highlighter-rouge">kCLLocationAccuracyHundredMeters</code>. This is how you want the location data to be as accurate. It is important to note that higher accuracy will require longer time to retrieve location data.
    <ol>
      <li><code class="highlighter-rouge">kCLLocationAccuracyKilometer </code> - within a kilometer</li>
      <li><code class="highlighter-rouge">kCLLocationAccuracyThreeKilometers</code> -within 3 kilometers. The higher, the better conservation of energy.</li>
      <li><code class="highlighter-rouge">kCLLocationAccuracyBestForNavigation</code>- usually used in navigation apps. Least energy efficient.
        <ol>
          <li>locationManager.activityType = .automotiveNavigation</li>
          <li>locationManager.distanceFilter = 0</li>
        </ol>
      </li>
      <li><code class="highlighter-rouge">kCLLocationAccuracyNearestTenMeters</code> - less energy efficient.</li>
    </ol>
  </li>
  <li>If you use <code class="highlighter-rouge">requestLocation()</code>, it will only gather location data once. However, this takes 10 seconds as opposed to <code class="highlighter-rouge">startUpdatingLocation()</code>, which fires immediately.</li>
</ol>
:ET