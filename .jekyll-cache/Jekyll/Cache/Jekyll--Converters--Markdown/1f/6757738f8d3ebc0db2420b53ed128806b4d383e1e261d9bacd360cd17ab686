I"H<p>Most articles regarding this are overwhelming and Iâ€™m about to make it easier. This is based on Brian Voongâ€™s tutorial. I urge you to watch the video too because, essentially, that is what Iâ€™m basing this article on.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/q0-DIJszYRo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>In his tutorial, there are two views. One trying to present the other, the other view has a button to go back to the first view.</p>

<p>His objective in this tutorial was to simply demonstrate how the presented view is removed from memory when popping back to the previous view by the use of <code class="highlighter-rouge">[weak self]</code> or by <code class="highlighter-rouge">[unowned self]</code>. His closures are a bit too advanced to understand, so letâ€™s make it more conceptual than actual.</p>

<p>Say this is the presented view.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class 2ndView: View {
	deinit {
		print("The memory used by this view is being released")
	}
	
	self.viewDidLoad (){
		closure {() in
			self.alert()
		}
	}
	
	func alert() {...}
}
</code></pre></div></div>

<p>By doing it like this, the <code class="highlighter-rouge">self</code> in the closure, by default, holds a strong reference to itself, being the 2ndView. And when it does that, it simply makes it difficult to relase the 2ndView from the memory when going back to the 1stView. And by <code class="highlighter-rouge">strong</code>, it means the <code class="highlighter-rouge">deinit</code> wonâ€™t be working here.</p>

<p>In order to make the reference to 2ndView less strong, we use weak by replacing our closure to this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>closure { [weak self] () in
	self?.alert()
}
</code></pre></div></div>

<p>Notice that we made the <code class="highlighter-rouge">self</code> an optional. By using weak, we canâ€™t guarantee that <code class="highlighter-rouge">self</code> always has a value. If we are certain that <code class="highlighter-rouge">self</code> always returns a value, then we can use <code class="highlighter-rouge">unowned</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>closure { [unowned self] () in
	self.alert()
}
</code></pre></div></div>

<p>Both solves the same memory problem and will print out <code class="highlighter-rouge">The memory used by this view is being released</code> every time the 2ndView is unloaded.</p>

<p>This can also be done for variables pointing to classes. Letâ€™s have an example of the 1stView:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class 1stView: View {
	weak var 2ndView: View?
	
	self.viewDidLoad() {
		navigationController?.pushViewController(2ndView(), animated: true)
	}
}

1stView = nil
// The memory used by this view is being released
</code></pre></div></div>

<p>After unloading the 1stView, our 2ndView is also unloaded ang gives us the printed message from its <code class="highlighter-rouge">deinit</code>.</p>

<p>Hereâ€™s a <a href="https://www.avanderlee.com/swift/weak-self/">post by Antoine v.d. SwiftLee ðŸš€</a> which explains what ARC does behind the curtains.</p>

:ET