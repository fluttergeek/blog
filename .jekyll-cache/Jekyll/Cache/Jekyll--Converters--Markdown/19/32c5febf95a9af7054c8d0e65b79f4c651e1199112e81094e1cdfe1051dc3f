I"f<p>One of my favorite online tutors is Let’s Build That App. He’s really good with his YouTube thing going on. Makes me understand a lot of Swift stuff that I never imagined to be digging into. Most of this article is coming from his tutorial and I’ve also included his video in case anyone’s interested.</p>

<p>Async is concurrent. It does not wait for something to finish for it to start working. When you hear async, think low priority, background, and fetching data. That much I know.</p>

<p>Fernando Martín Ortiz is another iOS developer who’s talked about this. The callback hell he says. Callback hell looks exactly like our picture above. We must refrain from using callbacks with our async functions to avoid spaghetti like codes. Instead, like Let’s Build That App, use <code class="highlighter-rouge">Futures</code>. Whatever the hell that means. Kidding aside, it actually means that it has to <code class="highlighter-rouge">return</code> something in the future instead of making a <code class="highlighter-rouge">callback</code>. Read more about his thoughts on that <a href="https://medium.com/ios-os-x-development/managing-async-code-in-swift-d7be44cae89f#targetText=You%20call%20that%20function%20and,resolved%2C%20is%20commonly%20called%20then.">here</a>.</p>

<p>Now let me dive into Let’s Build That App’s (LBTA) precious little code from his video tutorial. In this video, he shows how to convert a callback async function into a future async function. There’s a lot of code here that’ll overwhelm a newbie.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/JHqxmBFrWl8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum NetworkError: Error {
    case url
    case statusCode
    case standard
}
</code></pre></div></div>

<p>Let’s start with the simplest tiniest detail that we have to wrap our brains with. If you’re a newbie, you might be intimidated from using enums. I know I do. <code class="highlighter-rouge">NetworkError</code> is just a name here and you can change it however you like. It inherits an <code class="highlighter-rouge">Error</code> which has no requirements of its own, you can declare conformance on any custom type you create. Hence, url, statusCode, and standard are just made up by LBTA. You can add more cases of your own words. In the end, these cases will be printed as strings anyway. For example, case url when printed <code class="highlighter-rouge">print(NetworkError.url)</code> will return “url”.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func fetchSomethingAsyncAwait(url: String) throws -&gt; Data? {
    guard let dummyURL = URL(string: url) else {
        throw NetworkError.url
    }
    
    var data: Data?
    var response: URLResponse?
    var error: Error?
    
    // Semaphore
    let semaphore = DispatchSemaphore(value: 0)
		
    URLSession.shared.dataTask(with: dummyURL) { (d, r, e) in
        data = d
        response = r
        error = e
        
        semaphore.signal()
    }.resume()
    
    // this will return a result, doing this will just get rid of the warning
    // but its still functional without assigning it to an underscore
    _ = semaphore.wait(timeout: .distantFuture)
    
    if let httpURLResponse = response as? HTTPURLResponse, httpURLResponse.statusCode &gt; 300 {
        throw NetworkError.statusCode
    }
    
    if error != nil {
        throw NetworkError.standard
    }
    
    return data
}
</code></pre></div></div>

<p>This is a <code class="highlighter-rouge">Future</code>. You know when you see one because it needs to return something, <code class="highlighter-rouge">Data?</code>. This is a function that can throw an error. So every time you use this function, you must always put it inside a do <code class="highlighter-rouge">try</code> catch.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do {
    let data = try fetchSomethingAsyncAwait(url: "http://google.com")
} catch {
    print("Failed to Fetch stuff: ", error)
    return
}
</code></pre></div></div>

<p>If this catches an error, it might print something like “Failed to Fetch stuff: statusCode”.</p>

<p>But the most intriguing part of his code is the semaphore. He scheduled the return to execute after the URLSession has finished its task. If there was no semaphore, then the data? might return nil. That’s because he didn’t initialize data when he first created it and it is an optional. With this semaphore superpower, he was able to ask the main thread to wait until a <code class="highlighter-rouge">signal()</code> has been found in the distant future.</p>

<p>URLSession is the async here, and it is making another thread in the background. Once URLSession’s task reached til the end of its closure, the <code class="highlighter-rouge">semaphore.signal()</code> will ask the <code class="highlighter-rouge">fetchSomethingAsyncAwait()</code> function to continue where it left off.</p>

<p><code class="highlighter-rouge">if let httpURLResponse = response as? HTTPURLResponse, httpURLResponse.statusCode &gt; 300</code> is the next thing after coming back to the main thread, then the <code class="highlighter-rouge">if error != nil</code>. This way, if no error has been thrown, the <code class="highlighter-rouge">return data</code> will surely have a value to return, otherwise, it returns nil.</p>

<p>To know better about semaphores, check <a href="/blog/where-better-to-understand-semaphores-swift/">this</a> out.</p>

:ET